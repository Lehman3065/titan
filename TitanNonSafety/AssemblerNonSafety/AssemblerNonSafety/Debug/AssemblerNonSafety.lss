
AVRASM ver. 2.1.57  C:\Work\Titan\TitanNonSafety\AssemblerNonSafety\AssemblerNonSafety\AssemblerNonSafety.asm Mon May 28 16:27:27 2018

[builtin](2): Including file 'C:\Program Files\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\tn20def.inc'
                 
                 /* 
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny20.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn20def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny20
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny20
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN20DEF_INC_
                 #define _TN20DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny20
                 #pragma AVRPART ADMIN PART_NAME ATtiny20
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x91
                 .equ	SIGNATURE_002	= 0x0f
                 
                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	CCP	= 0x3c
                 .equ	RSTFLR	= 0x3b
                 .equ	MCUCR	= 0x3a
                 .equ	OSCCAL	= 0x39
                 .equ	CLKMSR	= 0x37
                 .equ	CLKPSR	= 0x36
                 .equ	PRR	= 0x35
                 .equ	QTCSR	= 0x34
                 .equ	NVMCMD	= 0x33
                 .equ	NVMCSR	= 0x32
                 .equ	WDTCSR	= 0x31
                 .equ	SPCR	= 0x30
                 .equ	SPSR	= 0x2f
                 .equ	SPDR	= 0x2e
                 .equ	TWSCRA	= 0x2d
                 .equ	TWSCRB	= 0x2c
                 .equ	TWSSRA	= 0x2b
                 .equ	TWSA	= 0x2a
                 .equ	TWSAM	= 0x29
                 .equ	TWSD	= 0x28
                 .equ	GTCCR	= 0x27
                 .equ	TIMSK	= 0x26
                 .equ	TIFR	= 0x25
                 .equ	TCCR1A	= 0x24
                 .equ	TCCR1B	= 0x23
                 .equ	TCCR1C	= 0x22
                 .equ	TCNT1H	= 0x21
                 .equ	TCNT1L	= 0x20
                 .equ	OCR1AL	= 0x1e
                 .equ	OCR1AH	= 0x1f
                 .equ	OCR1BL	= 0x1c
                 .equ	OCR1BH	= 0x1d
                 .equ	ICR1L	= 0x1a
                 .equ	ICR1H	= 0x1b
                 .equ	TCCR0A	= 0x19
                 .equ	TCCR0B	= 0x18
                 .equ	TCNT0	= 0x17
                 .equ	OCR0A	= 0x16
                 .equ	OCR0B	= 0x15
                 .equ	ACSRA	= 0x14
                 .equ	ACSRB	= 0x13
                 .equ	ADCSRA	= 0x12
                 .equ	ADCSRB	= 0x11
                 .equ	ADMUX	= 0x10
                 .equ	ADCH	= 0x0f
                 .equ	ADCL	= 0x0e
                 .equ	DIDR0	= 0x0d
                 .equ	GIMSK	= 0x0c
                 .equ	GIFR	= 0x0b
                 .equ	PCMSK1	= 0x0a
                 .equ	PCMSK0	= 0x09
                 .equ	PORTCR	= 0x08
                 .equ	PUEB	= 0x07
                 .equ	PORTB	= 0x06
                 .equ	DDRB	= 0x05
                 .equ	PINB	= 0x04
                 .equ	PUEA	= 0x03
                 .equ	PORTA	= 0x02
                 .equ	DDRA	= 0x01
                 .equ	PINA	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTB ************************
                 ; PORTCR - Port Control Register
                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                 
                 ; PUEB - Pull-up Enable Control Register
                 .equ	PUEB0	= 0	; 
                 .equ	PUEB1	= 1	; 
                 .equ	PUEB2	= 2	; 
                 .equ	PUEB3	= 3	; 
                 
                 ; PORTB - Input Pins, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 
                 ; PINB - Port B Data register
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control and Status Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	REFS	= 6	; Reference Selection Bit
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	ADLAR	= 3	; 
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                 .equ	ADC3D	= 3	; AREF Digital Input Disable
                 .equ	ADC4D	= 4	; ADC3 Digital input Disable
                 .equ	ADC5D	= 5	; ADC4 Digital input Disable
                 .equ	ADC6D	= 6	; ADC5 Digital input Disable
                 .equ	ADC7D	= 7	; ADC6 Digital input Disable
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSRA - Analog Comparator Control And Status Register A
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; ACSRB - Analog Comparator Control And Status Register B
                 .equ	ACME	= 2	; Analog Comparator Multiplexer Enable
                 .equ	HLEV	= 6	; Hysteresis Level
                 .equ	HSEL	= 7	; Hysteresis Select
                 
                 
                 ; ***** CPU **************************
                 ; CCP - Configuration Change Protection
                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                 
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; CLKMSR - Clock Main Settings Register
                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                 
                 ; CLKPSR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRTIM0	= 1	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 2	; Power Reduction Timer/Counter1
                 .equ	PRSPI	= 3	; Power Reduction Serial Peripheral Interface
                 .equ	PRTWI	= 4	; Power Reduction TWI
                 
                 ; RSTFLR - Reset Flag Register
                 .equ	PORF	= 0	; Power-on Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                 
                 ; NVMCMD - Non-Volatile Memory Command
                 .equ	NVMCMD0	= 0	; 
                 .equ	NVMCMD1	= 1	; 
                 .equ	NVMCMD2	= 2	; 
                 .equ	NVMCMD3	= 3	; 
                 .equ	NVMCMD4	= 4	; 
                 .equ	NVMCMD5	= 5	; 
                 
                 ; MCUCR - MCU Control Register
                 .equ	SE	= 0	; 
                 .equ	SM0	= 1	; 
                 .equ	SM1	= 2	; 
                 .equ	SM2	= 3	; 
                 .equ	BODS	= 4	; 
                 .equ	ISC00	= 6	; 
                 .equ	ISC01	= 7	; 
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	PCIF0	= 4	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 5	; Pin Change Interrupt Flag 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	PCIE0	= 4	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 5	; Pin Change Interrupt Enable 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0A - Timer/Counter 0 Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                 
                 ; TCCR0B - Timer/Counter 0 Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; Waveform Generation Mode
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TIMSK - Timer Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter Output Compare Match B Interrupt Enable
                 .equ	TOIE1	= 3	; Overflow Interrupt Enable
                 .equ	OCIE1A	= 4	; Output Compare A Match Interrupt Enable
                 .equ	OCIE1B	= 5	; Output Compare B Match Interrupt Enable
                 .equ	ICIE1	= 7	; Input Capture Interrupt Enable
                 
                 ; TIFR - Overflow Interrupt Enable
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Output Compare Flag 0 A
                 .equ	OCF0B	= 2	; Output Compare Flag 0 B
                 .equ	TOV1	= 3	; Timer Overflow Flag
                 .equ	OCF1A	= 4	; Timer Output Compare Flag 1A
                 .equ	OCF1B	= 5	; Timer Output Compare Flag 1B
                 .equ	ICF1	= 7	; Input Capture Flag
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSR	= 0	; Prescaler Reset
                 .equ	TSM	= 7	; Timer Synchronization Mode
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 
                 ; ***** TWI **************************
                 ; TWSCRA - TWI Slave Control Register A
                 .equ	TWSME	= 0	; TWI Smart Mode Enable
                 .equ	TWPME	= 1	; TWI Promiscuous Mode Enable
                 .equ	TWSIE	= 2	; TWI Stop Interrupt Enable
                 .equ	TWEN	= 3	; Two-Wire Interface Enable
                 .equ	TWASIE	= 4	; TWI Address/Stop Interrupt Enable
                 .equ	TWDIE	= 5	; TWI Data Interrupt Enable
                 .equ	TWSHE	= 7	; TWI SDA Hold Time Enable
                 
                 ; TWSCRB - TWI Slave Control Register B
                 .equ	TWCMD0	= 0	; 
                 .equ	TWCMD1	= 1	; 
                 .equ	TWAA	= 2	; TWI Acknowledge Action
                 
                 ; TWSSRA - TWI Slave Status Register A
                 .equ	TWAS	= 0	; TWI Address or Stop
                 .equ	TWDIR	= 1	; TWI Read/Write Direction
                 .equ	TWBE	= 2	; TWI Bus Error
                 .equ	TWC	= 3	; TWI Collision
                 .equ	TWRA	= 4	; TWI Receive Acknowledge
                 .equ	TWCH	= 5	; TWI Clock Hold
                 .equ	TWASIF	= 6	; TWI Address/Stop Interrupt Flag
                 .equ	TWDIF	= 7	; TWI Data Interrupt Flag.
                 
                 ; TWSA - TWI Slave Address Register
                 .equ	TWSA0	= 0	; TWI slave address bit
                 .equ	TWSA1	= 1	; TWI slave address bit
                 .equ	TWSA2	= 2	; TWI slave address bit
                 .equ	TWSA3	= 3	; TWI slave address bit
                 .equ	TWSA4	= 4	; TWI slave address bit
                 .equ	TWSA5	= 5	; TWI slave address bit
                 .equ	TWSA6	= 6	; TWI slave address bit
                 .equ	TWSA7	= 7	; TWI slave address bit
                 
                 ; TWSD - TWI Slave Data Register
                 .equ	TWSD0	= 0	; TWI slave data bit
                 .equ	TWSD1	= 1	; TWI slave data bit
                 .equ	TWSD2	= 2	; TWI slave data bit
                 .equ	TWSD3	= 3	; TWI slave data bit
                 .equ	TWSD4	= 4	; TWI slave data bit
                 .equ	TWSD5	= 5	; TWI slave data bit
                 .equ	TWSD6	= 6	; TWI slave data bit
                 .equ	TWSD7	= 7	; TWI slave data bit
                 
                 ; TWSAM - TWI Slave Address Mask Register
                 .equ	TWAE	= 0	; TWI Address Enable
                 .equ	TWSAM1	= 1	; TWI Address Mask Bit 1
                 .equ	TWSAM2	= 2	; TWI Address Mask Bit 2
                 .equ	TWSAM3	= 3	; TWI Address Mask Bit 3
                 .equ	TWSAM4	= 4	; TWI Address Mask Bit 4
                 .equ	TWSAM5	= 5	; TWI Address Mask Bit 5
                 .equ	TWSAM6	= 6	; TWI Address Mask Bit 6
                 .equ	TWSAM7	= 7	; TWI Address Mask Bit 7
                 
                 
                 ; ***** PORTA ************************
                 ; PORTCR - Port Control Register
                 .equ	BBMA	= 0	; Break-Before-Make Mode Enable
                 
                 ; PUEA - Pull-up Enable Control Register
                 .equ	PUEA0	= 0	; 
                 .equ	PUEA1	= 1	; 
                 .equ	PUEA2	= 2	; 
                 .equ	PUEA3	= 3	; 
                 .equ	PUEA4	= 4	; 
                 .equ	PUEA5	= 5	; 
                 .equ	PUEA6	= 6	; 
                 .equ	PUEA7	= 7	; 
                 
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; 
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; 
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; 
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; 
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; 
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; 
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; 
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; 
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Data Direction Register, Port A
                 .equ	DDA0	= 0	; 
                 .equ	DDA1	= 1	; 
                 .equ	DDA2	= 2	; 
                 .equ	DDA3	= 3	; 
                 .equ	DDA4	= 4	; 
                 .equ	DDA5	= 5	; 
                 .equ	DDA6	= 6	; 
                 .equ	DDA7	= 7	; 
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; 
                 .equ	PINA1	= 1	; 
                 .equ	PINA2	= 2	; 
                 .equ	PINA3	= 3	; 
                 .equ	PINA4	= 4	; 
                 .equ	PINA5	= 5	; 
                 .equ	PINA6	= 6	; 
                 .equ	PINA7	= 7	; 
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Clock Select bit 0
                 .equ	CS11	= 1	; Clock Select 1 bit 1
                 .equ	CS12	= 2	; Clock Select1 bit 2
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                 
                 ; TCNT1H - Timer/Counter1 High
                 .equ	TCNT1_8	= 0	; 
                 .equ	TCNT1_9	= 1	; 
                 .equ	TCNT1_10	= 2	; 
                 .equ	TCNT1_11	= 3	; 
                 .equ	TCNT1_12	= 4	; 
                 .equ	TCNT1_13	= 5	; 
                 .equ	TCNT1_14	= 6	; 
                 .equ	TCNT1_15	= 7	; 
                 
                 ; TCNT1L - Timer/Counter1 Low
                 .equ	TCNT1_0	= 0	; 
                 .equ	TCNT1_1	= 1	; 
                 .equ	TCNT1_2	= 2	; 
                 .equ	TCNT1_3	= 3	; 
                 .equ	TCNT1_4	= 4	; 
                 .equ	TCNT1_5	= 5	; 
                 .equ	TCNT1_6	= 6	; 
                 .equ	TCNT1_7	= 7	; 
                 
                 ; TIMSK - Timer Interrupt Mask Register
                 ;.equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 ;.equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 ;.equ	OCIE0B	= 2	; Timer/Counter Output Compare Match B Interrupt Enable
                 ;.equ	TOIE1	= 3	; Overflow Interrupt Enable
                 ;.equ	OCIE1A	= 4	; Output Compare A Match Interrupt Enable
                 ;.equ	OCIE1B	= 5	; Output Compare B Match Interrupt Enable
                 ;.equ	ICIE1	= 7	; Input Capture Interrupt Enable
                 
                 ; TIFR - Overflow Interrupt Enable
                 ;.equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 ;.equ	OCF0A	= 1	; Output Compare Flag 0 A
                 ;.equ	OCF0B	= 2	; Output Compare Flag 0 B
                 ;.equ	TOV1	= 3	; Timer Overflow Flag
                 ;.equ	OCF1A	= 4	; Timer Output Compare Flag 1A
                 ;.equ	OCF1B	= 5	; Timer Output Compare Flag 1B
                 ;.equ	ICF1	= 7	; Input Capture Flag
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSR	= 0	; Prescaler Reset
                 ;.equ	TSM	= 7	; Timer Synchronization Mode
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; BYTE0 fuse bits
                 .equ	RSTDISBL	= 0	; Disable external reset
                 .equ	WDTON	= 1	; Watch dog timer always on
                 .equ	CKOUT	= 2	; Output external clock
                 .equ	BODLEVEL0	= 4	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 5	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 6	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x03ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0040
                 .equ	SRAM_SIZE	= 128
                 .equ	RAMEND	= 0x00bf
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x0000
                 .equ	EEPROMEND	= 0x0000
                 
                 ; ***** MEMORY MAPPED NVM ************************************************
                 .equ	MAPPED_FLASH_START	= 0x4000
                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                 .equ	MAPPED_CONFIG_0	= 0x3f40
                 .equ	MAPPED_CALIB_0	= 0x3f80
                 .equ	MAPPED_SIGN_0	= 0x3fc0
                 .equ	MAPPED_SIGN_1	= 0x3fc1
                 .equ	MAPPED_SIGN_2	= 0x3fc2
                 .equ	MAPPED_FLASH_SIZE	= 0x0800
                 .equ	MAPPED_FLASH_END	= 0x47ff
                 #pragma AVRPART MEMORY PROG_FLASH 2048
                 #pragma AVRPART MEMORY EEPROM 0
                 #pragma AVRPART MEMORY INT_SRAM SIZE 128
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0003	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x0004	; Watchdog Time-out
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Input Capture
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x0009	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000a	; Timer/Counter0 Compare Match B
                 .equ	OVF0addr	= 0x000b	; Timer/Counter0 Overflow
                 .equ	ACIaddr	= 0x000c	; Analog Comparator
                 .equ	ADCCaddr	= 0x000d	; Conversion Complete
                 .equ	TWIaddr	= 0x000e	; Two-Wire Interface
                 .equ	SPIaddr	= 0x000f	; Serial Peripheral Interface
                 .equ	QTRIPaddr	= 0x0010	; Touch Sensing
                 
                 .equ	INT_VECTORS_SIZE	= 17	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _TN20DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 Проверено:
                 - моменты включения ADC для измерения напряжений
                 - работа поджига по флагу  bIgnition
                 - передача через оптопару 30 бит и 6 бит в разных режимах
                 - значения 6 бит
                 Не проверено:
                 - значения 30 бит
                 - прием через оптопару команды ПОДЖИГ
                 - установка флага bFire при наличии пламени
                 - устойчивость работы при пересбросах
                 Не сделано:
                 - заполнение RJMP ? пустой облати памяти
                 
                  *	AssemblerNonSafety.asm
                  *  Программа для котла Титан (высоковольтный микроконтроллер)
                  *  Created: 26.02.2018 11:44:07
                  *   Author: Alexey81 */ 
                  ;.include "tn20def.inc"
                 
                 .EQU	Fclk = 250		; kHz - тактовая частота процессора
                 .EQU	bLedIn = 4		; PA4 вход c оптрона гальванической изоляции. Активное состояние = 0
                 						; Нужно для включения поджига. Для этого подаются импульсы с периодом 25..30 мс
                 .EQU	bLedT1 = 7		; PA7 = T1 вход c оптрона гальванической изоляции. Активное состояние = 0
                 .EQU	PortLedIn = PORTA
                 .EQU	InUREF = 1		; ADC1 напряжение опорного источника 3,3 В
                 .EQU	InUGND = 2		; ADC2 напряжение корпуса прибора относительно нейтрали
                 .EQU	InUPhase = 3	; ADC3 напряжение фазы (после аварийного термостата тепрературы воды)
                 .EQU	InUFire = 5		; ADC5 напряжение датчика пламени
                 .EQU	bDEBUG = 6		; DEBUG pin
                 .EQU	PortU = PORTA
                 
                 .EQU	bLedOut = 2		; PB2 = к аноду светодиода оптрона гальванической развязки
                 .EQU	PortLedOut = PORTB
                 .EQU	bPhase = 0		; PB0 - цифровой сигнал фазы 50 Гц с питающего напряжения
                 .EQU	PortPhase = PORTB
                 .EQU	bIgnitionOut = 1; PB1 - выход на включение тиристора поджига. Активный уровень = 0
                 .EQU	PortIgnitionOut = PORTB
                 
                 .EQU	Vcc = 5100			; mV (Vcc = 5100mV - BZX84-C5V1 DIOTEC, HOTTECH, SAMTECH)
                 .EQU	CorrectionT = 16	; на CorrectionT тактов процессора опережаем отсчеты для попадания на середины полупериодов сети
                 .EQU	SendStart = 25		; задержка начала передачи через гальваническую развязку от старта передачи
                 .EQU	Duration_0 = (Fclk/(3*4))	; длительность интервала при передаче 0 (0,25 мс)
                 .EQU	Duration_1 = (Fclk/(3*2))	; длительность интервала при передаче 1 (0,5 мс) - передача 30 бит гарантировано укладывается в период
                 .EQU	DurationStart = ((Duration_0 + Duration_1)/2)	; длительность стартового интервала при передаче
                 .EQU	EndOfFrame = (Fclk * 3) ; за 3 мс до конца кадра начинаем ждать переход фазы через 0 (Fclk кГц - частора процессора)
                 .EQU	UFirePorog = 128	; порог срабатывания датчика пламени
                 .EQU	CInputTimeout = ((50 * Fclk) / 256)	; 50 мс отсытствуют импульсы от оптрона - поджиг не нужен : IgnitionStatus = 0
                 .EQU	CInputTimeoutMin = ((20 * Fclk) / 256)	; менее 20 мс между импульсами от оптрона - поджиг не нужен : IgnitionStatus = 0
                 .EQU	CMinPeriodLength = ((12 * Fclk) / 256)	; 12 мс минимальный период сетевого напряжения
                 .EQU	CMaxPeriodLength = ((25 * Fclk) / 256)	; 25 мс максимальный период сетевого напряжения
                 .EQU	CInputDebounce = 3	; сколько должно совпасть периодов импульсов, чтобы IgnitionStatus стал 1
                 .EQU	CInputMaxJitter = 2 ; максимальное дрожание периода импульсов разрешающих поджиг (для учета совпадения периодов)
                 
                 .MACRO WriteByteToRegCCP_r16	; Load reg through r16
                 	ldi	r16, 0xD8		; Write signature for change enable of protected I/O register
                 	out	CCP, r16
                 	ldi r16, (@1)
                 	out (@0), r16
                 .ENDMACRO				; WriteByteToRegCCP_r16
                 
                 .MACRO WriteByteToReg_r16		; Load reg through r16
                 	ldi r16, (@1)
                 	out (@0), r16
                 .ENDMACRO				; WriteByteToReg_r16
                 
                 .MACRO SetMachStat_r16
                 	ldi r16, (@1)
                 	sts (@0), r16
                 .ENDMACRO				; SetMachStat_r16
                 
                 .MACRO WriteWordToReg_r16	; Load 16 bit reg through r16
                 	ldi r16, (HIGH(@1))
                 	out ((@0) + 1), r16
                 	ldi r16, (LOW(@1))
                 	out (@0), r16
                 .ENDMACRO				; WriteWordToReg_r16
                 
                 .MACRO ReadWordRegToMem_r16	; Load 16 bit reg through r16
                 	in r16, (@0)
                 	sts (@1), r16
                 	in r16, ((@0) + 1)
                 	sts ((@1) + 1), r16
                 .ENDMACRO				; ReadWordRegToMem_r16
                 
                 .MACRO ClrBitsReg31_r16	; Clr Register 20H..31H bits through r16
                 	in r16, (@0)
                 	andi r16, (0xFF - (@1))
                 	out (@0), r16
                 .ENDMACRO				; ClrBitsReg31_r16
                 
                 .MACRO SetBitsReg31_r16	; Set Register 20H..31H bits through r16
                 	in r16, (@0)
                 	ori r16, (@1)
                 	out (@0), r16
                 .ENDMACRO				; SetBitsReg31_r16
                 
                 .MACRO WriteByteToMem_r16	; Store Imm in Memiry through r16
                 	ldi r16, (@1)
                 	sts (@0), r16
                 .ENDMACRO				; WriteByteToMem_r16
                 
                 .MACRO WaitTrue		; Ждём "1" на входе
                 LWait:
                 	sbis (@0), (@1) 
                 	rjmp LWait		;$-4		
                 .ENDMACRO			; WaitTrue
                 
                 .MACRO WaitFalse	; Ждём "0" на входе
                 LWait:
                 	sbic (@0), (@1) 
                 	rjmp LWait		;$-4		
                 .ENDMACRO			; WaitFalse
                 
                 .MACRO CopyWordWord_r16	; копирование WORD to WORT в памяти through r16
                 	lds r16, (@1)
                 	sts (@0), r16
                 	lds r16, ((@1) + 1)
                 	sts ((@0) + 1), r16
                 .ENDMACRO
                 
                 .MACRO Load_Z_Ptr	; загрузка указателя Z 
                 	ldi r31, (HIGH(@0))
                 	ldi r30, (LOW(@0))
                 .ENDMACRO			; Load_Z_Ptr
                 
                 .MACRO Load16		; загрузка регистров из памяти
                 	lds @0, (@2)
                 	lds @1, ((@2) + 1)
                 .ENDMACRO			; Load16
                 
                 .MACRO Store16		; сщхранение регистров в память
                 	sts (@0), @1
                 	sts ((@0) + 1), @2
                 .ENDMACRO			; Store16
                 
                 .MACRO sub16u		; 16 бит вычитание регистровых пар
                 	sub	@0, @2
                 	sbc @1, @3 
                 .ENDMACRO			; sub16u
                 
                 .MACRO subi16u		; 16 бит вычитание константы из регистровой пары
                 	subi @0, (LOW(@2))
                 	sbci @1, (HIGH(@2))
                 .ENDMACRO			; subi16u
                 
                 .MACRO add16u		; 16 бит сложение регистровых пар
                 	add	@0, @2
                 	adc @1, @3 
                 .ENDMACRO			; add16u
                 
                 .MACRO div16u2		; 16 бит деление на "2" сдвигом вправо на 1 разряд
                 	lsr	@1
                 	ror @0 
                 .ENDMACRO			; div16u2
                 
                 .DSEG
                 /* Данные программы */
000040           MachineState:	.BYTE	1	; сотояние машины
                 .EQU	MachWaitStart = 11	; ждём начала измерения длительности машинного цикла
                 .EQU	MachIgnition = 10	; включаем поджиг и контролируем UFire
                 .EQU	MachEndStart = 9	; подготовить сохранение длительности машинного цикла
                 .EQU	MachInUPhase0 = 8	; измеряем InUPhase
                 .EQU	MachInUPhase1 = 7	; измеряем InUPhase и вычисляем средний квадрат
                 .EQU	MachInUGND0 = 6		; измеряем InUGND
                 .EQU	MachInUGND1 = 5		; измеряем InUGND и вычисляем средний квадрат
                 .EQU	MachInUFire = 4		; определение пламени по InUFire в разных полупериодах и измерение InUREF
                 .EQU	MachSerialOut = 3	; 3..2 передачи данных в главный контроллер
                 .EQU	MachSaveTime = 1	; подготовить очередное сохранение длительности машинного цикла
                 
000041           NewT1Value:		.BYTE	1	; 1 - запомнено новое значение T1Value
000042           T1Value:		.BYTE	2	; текущий старт машинного цикла в циклах контроллера (и начало нулевого периода! сети)
000044           PreT1Value:		.BYTE	2	; предыдущий старт машинного цикла в циклах контроллера
000046           MachLength:		.BYTE	2	; длина машинного цикла в циклах контроллера
000048           TStartPeriod:		.BYTE	2	; начало нулевого периода сети (счет идет с нулевого!)
                 ;StartT1:		.BYTE	2	; начало первого периода сети (счет идет с нулевого!)
                 ;StartT2:		.BYTE	2	; начало второго периода сети (счет идет с нулевого!)
                 ;StartT3:		.BYTE	2	; начало третьего периода сети (счет идет с нулевого!)
                 ;StartT4:		.BYTE	2	; начало четвертого периода сети (счет идет с нулевого!)
                 ;StartTMaxP:		.BYTE	2	; момент максимального положительного напряжения сети относительно начала периода сети
00004a           LengthDiv2:		.BYTE	2	; PeriodLength/2 = сдвиг вправо на 1 разряд
00004c           LengthDiv4:		.BYTE	2	; PeriodLength/4 = сдвиг вправо на 2 разряда
00004e           LengthDiv8:		.BYTE	2	; PeriodLength/8 = сдвиг вправо на 3 разряда
                 ;LengthDiv16:	.BYTE	2	; PeriodLength/16 = сдвиг вправо на 4 разряда
000050           LengthDiv32:	.BYTE	2	; MachLength/32 = сдвиг вправо на 5 разрядов - UFire первый отсчет
000052           LengthDiv64:	.BYTE	2	; MachLength/64 = сдвиг вправо на 6 разрядов
000054           Length3Div4:	.BYTE	2	; PeriodLength*3/4 = 3/4 периода сети - второй отсчет напряжения UFire ?
000056           Length3Div8:	.BYTE	2	; PeriodLength*3/8 = 3/4 полупериода (3/8 периода) сети - третий отсчет напряжения
000058           Length17Div32:	.BYTE	2	; PeriodLength*17/32 = UFire второй отсчет и затем момент поджига 
                 SendBuf:	; 4 байта - буфер значений для передачи в главный процессор через гальваническую развязку
00005a           UPhase2Sum:		.BYTE	3	; Сначала сумма квадратов отсчетов UPhase, потом - среднеквадратическое значение для передачи (мл. байт)
00005d           UGND2Sum:		.BYTE	3	; Сначала сумма квадратов отсчетов UGND, потом - среднеквадратическое значение для передачи (мл. байт)
                 T1ToSend:	; 2 байта - для текущего запоминания значения Т1 в начале передачи в главный процессор через гальваническую развязку
000060           UFireSum:		.BYTE	2	; Сумма отсчетов UFire
000062           FireStatus:		.BYTE	1	; Статус Fire (датчика пламени) -  (мл. бит)
                 .EQU	bFire = 0			; Бит, уазывающий на то, что пламя есть
000063           UREFVal:		.BYTE	1	; Отсчет UREF - значение для передачи
000064           ReseiveByte:	.BYTE	1	; Байт, принятый от главного процессора через гальваническую развязку
000065           IgnitionStatus: .BYTE	1	; Статус зажигания горелки
                 .EQU	bIgnition = 0		; Бит, уазывающий на то, что нужно включить зажигание горелки
000066           InputTimeout:	.BYTE	1	; Таймаут приема в мс (если доходит до CInputTimeout - значит сигнала на поджиг нет)
000067           InputDebounce:	.BYTE	1	; Счетчик антидребезга приемника с оптопары
                 
                 
                 
000068           PCINT1_ISR_regSave:	.BYTE	1 ; здесь сохраняются регистры при PCINT1_ISR
000069           TIM1_COMPB_ISR_regSave:	.BYTE	1 ; здесь сохраняются регистры при TIM1_COMPB_ISR
                  
                 
                 
                 .CSEG
                 /* Программа */
                 .ORG 0x0
000000 c01c      	rjmp power_reset	; Address 0x0000
000001 c01b      	rjmp power_reset	; Address 0x0001 INT0_ISR
000002 c01a      	rjmp power_reset	; Address 0x0002 PCINT0_ISR
000003 c00d      	rjmp PCINT1_ISR		; Address 0x0003 
000004 c018      	rjmp power_reset	; Address 0x0004 WDT_ISR
000005 c017      	rjmp power_reset	; Address 0x0005 TIM1_CAPT_ISR
000006 c013      	rjmp TIM1_COMPA_ISR	; Address 0x0006 
000007 c015      	rjmp power_reset	; Address 0x0007 TIM1_COMPB_ISR
000008 c014      	rjmp power_reset	; Address 0x0008 TIM1_OVF_ISR
000009 c013      	rjmp power_reset	; Address 0x0009 TIM0_COMPA_ISR
00000a c012      	rjmp power_reset	; Address 0x000A TIM0_COMPB_ISR
00000b c011      	rjmp power_reset	; Address 0x000B TIM0_OVF_ISR
00000c c010      	rjmp power_reset	; Address 0x000C ANA_COMP_ISR
00000d c00f      	rjmp power_reset	; Address 0x000D ADC_ISR
00000e c00e      	rjmp power_reset	; Address 0x000E TWI_SLAVE_ISR
00000f c00d      	rjmp power_reset	; Address 0x000F SPI_ISR
000010 c00c      	rjmp power_reset	; Address 0x0010 QTRIP_ISR
                 
                 .ORG 0x0011
                 
                 PCINT1_ISR:
                 	/* это прерывание разрешаем только при положительной полуволне фазы и кода 
                 	MachineState = MachSaveTime, MachEndStart, MachWaitStart
                 	, тогда при наступлении отрицательной полуволны фазы значение номера машинного цикла
                 	сохраняется в T1Value */
000011 ad08      	sts PCINT1_ISR_regSave, r16				; регистр статуса не сохраняем, т.к. флаги не меняются
000012 b500
000013 a902
000014 b501
000015 a903      	ReadWordRegToMem_r16 TCNT1L, T1Value	; сохраняем значение Таймера1 в T1Value
000016 e001      	ldi r16, 1
000017 a901      	sts NewT1Value, r16
000018 a508      	lds r16, PCINT1_ISR_regSave
000019 9518      	reti
                 
                 ; TIM1_CAPT_ISR:
                 	/* здесь когда принят очередной бит от оптопары
                 	ПОКА НЕ ПРИДУМАЛ
                 	делаем поллинг TIFR.ICF1 в основной программе */
                 ;	reti прерывание нельзя! - оно сбросит TIFR.ICF1 !!!
                 
                 TIM1_COMPA_ISR:
                 	/* здесь надо запускать ADC
                 	канал установлен заранее  */
00001a 9a97      	sbi ADCSRA, ADEN			; ADC enable
00001b 9a96      	sbi ADCSRA, ADSC			; Start ADC Conversion
00001c 9518      	reti
                 
                 /*
                 TIM1_COMPB_ISR:
                 	// здесь надо закончить импульс	оптопары
                 	sts TIM1_COMPB_ISR_regSave, r16
                 	WriteByteToReg_r16 TCCR1A, 0	; возвращаем светодиод оптрона под управления порта - гасим его
                 									; этот же регистр используем для поллинга об окончании импульса
                 	lds r16, TIM1_COMPB_ISR_regSave
                 	reti
                 */
                 
                 power_reset:
                 /*	init clock	*/
                 ;	WriteByteToRegCCP_r16 CLKMSR, 1	; Internal 128 kHz Oscillator (WDT Oscillator) set is a main clock (through r16)
                 ;	WriteByteToRegCCP_r16 CLKPSR, 0	; Prescaler = 1 (through r16)
                 
00001d ed08
00001e bf0c
00001f e000
000020 bf07      	WriteByteToRegCCP_r16 CLKMSR, 0	; Calibrated Internal 8 MHz Oscillator set is a main clock (through r16) - after reset value
000021 ed08
000022 bf0c
000023 e005
000024 bf06      	WriteByteToRegCCP_r16 CLKPSR, 5	; Prescaler = 32 (through r16) => Fclk = 250 kHz
                 
000025 ed08
000026 bf0c
000027 e00c
000028 bf01      	WriteByteToRegCCP_r16 WDTCSR, ((1<<WDE) + 4) ; Watchdog enable Twd = 250ms (through r16)
000029 e20e
00002a b90d      	WriteByteToReg_r16	DIDR0, ((1<<InUREF)|(1<<InUGND)|(1<<InUPhase)|(1<<InUFire)) ; отключаем цифровые входы, там, где аналог
                 
00002b b70b      	in	r16, RSTFLR		; polling Power On Reset
00002c 2711      	clr	r17
00002d bf1b      	out	RSTFLR, r17
00002e ff00      	sbrs r16, PORF
00002f c004      	rjmp HOT_reset
                 
                 COOL_reset:
000030 27aa      	clr	r26		; InputPrevPause
000031 27bb      	clr r27		; InputDebounce
000032 adb5      	sts IgnitionStatus, r27 ; IgnitionStatus = 0
000033 adb2      	sts FireStatus, r27		; FireStatus = 0
                 
                 HOT_reset:
                 /*	init Power Management	*/
000034 e10a
000035 bf05      	WriteByteToReg_r16 PRR, ((1<<PRTIM0) + (1<<PRTWI) + (1<<PRSPI)) ; Stop clock for TIM0, I2C & SPI
                 
000036 e003
000037 b908      	WriteByteToReg_r16 PORTCR, 3	; Break-Before-Make Mode for PORTA & PORTB Enable
                 /*	init PORTA	*/
                 	// WriteByteToReg_r16 PUEA, 0	; no pull-up - after reset value
                 	// WriteByteToReg_r16 PORTA, 0	; - after reset value
000038 e400
000039 b901      	WriteByteToReg_r16 DDRA, (1<<bDEBUG)	; bDEBUG - output
                 
                 /*	init PORTB	*/
00003a e008
00003b b907      	WriteByteToReg_r16 PUEB, (1<<PUEB3) ; ~RESET: pull-up
00003c e002
00003d b906      	WriteByteToReg_r16 PORTB, (1<<bIgnitionOut) ; поджиг не активен
00003e ef0e
00003f b905      	WriteByteToReg_r16 DDRB, (0xFF - (1<<bPhase))	; PB0 - input
                 
                 /* init Timer1  на счет циклов контроллера */
                 	// WriteByteToReg_r16 TCCR1A, 0 ; after reset value
                 	// WriteWordToReg_r16 OCR1AL, 0 ; after reset value
                 	// WriteWordToReg_r16 OCR1BL, 0 ; after reset value
000040 e800
000041 bd03      	WriteByteToReg_r16 TCCR1B, (1<<ICNC1) ; Input Capture Noise Canceler ON  ??????????????????????????
000042 e001
000043 bd03      	WriteByteToReg_r16 TCCR1B, (1<<CS10) ; clkI/O /1 (No prescaling) - start timer
                 
                 /*	init ADC  */
                 	// WriteByteToReg_r16 ADCSRA, 0	; ADC Prescaler = 2 - after reset value
                 
                 /*  init Machine
                 	Полный цикл = 6 периодав сети 50Гц
                 	- в первых 2 периодах  измеряется напряжение InUPhase
                 	- в следующих 2 - измеряется InUGND
                 	- в следующем периоде измеряется InUREF, наличие пламени определяется по InUFire в разных полупериодах
                 	- в остальных 1 периодах сети осуществляется передача 
                 	измерений и флагов в главный контроллер через последовательный канал
                 	с оптической развязкой */
000044 e00b
000045 a900      	SetMachStat_r16	MachineState, MachWaitStart
000046 2700      	clr r16
000047 a901      	sts NewT1Value, r16
                 
                 /*  init interrupt	*/
000048 e100
000049 b909      	WriteByteToReg_r16 PCMSK0, (1<<bLedIn) ; PCINT4 enable - прерывание по изменению сигнала посл. интерф.
00004a e001
00004b b90a      	WriteByteToReg_r16 PCMSK1, (1<<bPhase) ; PCINT8 enable - прерывание по изменению фазы
                 
                 	// WriteByteToReg_r16 TIMSK, 0 ; after reset value
                 	// WriteByteToReg_r16 GIMSK, 0 ; after reset value
00004c 9478      	sei		; global interrupt enable
                 
                 
                 
                 
                 /*
                 LOOOP:
                 	wdr
                 	nop
                 
                 	in r20, TCNT1L		; запоминаем текущее значение таймера
                 	in r21, TCNT1H		; r20:r21 - накапливаем новые значения таймера для включений оптрона
                 	bst r21, 0			; через флаг Т
                 	brtc ClearDebug
                 
                 SetDebug:
                 	sbi PORTA, bDEBUG
                 
                 	rjmp LOOOP
                 
                 ClearDebug:
                 	cbi PORTA, bDEBUG
                 
                 
                 	rjmp LOOOP
                 
                 
                 
                 	sbi PORTA, bDEBUG
                 
                 	nop
                 
                 	cbi PORTA, bDEBUG
                 
                 
                 
                 	rjmp LOOOP
                 
                 
                 
                 
                 */
                 
                 
                 ;	rjmp Send30BitToMain
                 
00004d c063      	rjmp MainLoop
                 
                 SetSendBuf:					; - must be MACRO ???
00004e 2733      	clr r19					; здесь накапливаем контрольную сумму, которую потом свернем до 4 бит исключающим или nibbles
00004f a30a      	lds r16, UPhase2Sum
000050 0f30      	add	r19, r16
000051 ab0b      	sts	(SendBuf + 1), r16
000052 a30d      	lds r16, UGND2Sum
000053 0f30      	add	r19, r16
000054 ab0c      	sts	(SendBuf + 2), r16
000055 a503      	lds r16, UREFVal
000056 0f30      	add	r19, r16
000057 ab0d      	sts	(SendBuf + 3), r16
000058 a502      	lds r16, FireStatus		; bit 0 - FireStatus
000059 a525      	lds r18, IgnitionStatus
00005a fb20      	bst r18, bIgnition		; через флаг Т
00005b f901      	bld r16, 1				; bit 1 - bIgnition - возвращаем как подтверждение приема
00005c 7003      	andi r16, 0x03			; оставляем биты 0, 1
00005d 0f30      	add	r19, r16			; r19 - контрольная сумма
00005e 2f23      	mov	r18, r19			; сворачиваем её до 4 бит
00005f 9522      	swap r18
000060 0f32      	add r19, r18
000061 0f33      	lsl r19
000062 0f33      	lsl r19
000063 2b03      	or r16, r19
000064 730f      	andi r16, 0x3F			; оставляем 6 бит (0 - FireStatus, 1 - Ignition, 2..5 - control sum)
000065 ab0a      	sts	(SendBuf + 0), r16  ; сначала передаем флаги и контрольную сумму
000066 9508      	ret
                 
                 SendFire:
000067 a522      	lds r18, FireStatus		; bit 0 - FireStatus
000068 fb20      	bst r18, bFire			; через флаг Т
000069 f900      	bld r16, 0				; bit 0 - bFire - возвращаем флаг наличия пламени
00006a f902      	bld r16, 2				; bit 2 - bFire - возвращаем флаг наличия пламени
00006b f904      	bld r16, 4				; bit 4 - bFire - возвращаем флаг наличия пламени
                 
00006c a525      	lds r18, IgnitionStatus
00006d fb20      	bst r18, bIgnition		; через флаг Т
00006e f901      	bld r16, 1				; bit 1 - bIgnition - возвращаем как подтверждение приема
00006f f903      	bld r16, 3				; bit 1 - bIgnition - возвращаем как подтверждение приема
000070 f905      	bld r16, 5				; bit 1 - bIgnition - возвращаем как подтверждение приема
                 
000071 e02c      	ldi r18, ((1<<2)|(1<<3)); инвертируем 2 средних бита
000072 2702      	eor r16, r18
000073 730f      	andi r16, 0x3F
000074 ab0a      	sts	(SendBuf + 0), r16  ; передаем флаги и контрольную сумму
000075 e086      	ldi r24, 6				; всего 6 бит: 2 флага, 2 флага инверсных и снова 2 флага
000076 c001      	rjmp SendBuffer
                 
                 Send30BitToMain:
000077 e18e      	ldi r24, 30				; будем передавать 30 бит
                 
                 SendBuffer:					; - must be MACRO ???
000078 e0f0
000079 e5ea      	Load_Z_Ptr SendBuf	; отсюда будем передавать
00007a e021      	ldi r18, 1			; стартовый импульс
00007b e030      	ldi r19, 0			; коррекция
00007c d018      	rcall SendImpuls
00007d e12e      	ldi r18, (DurationStart)	; стартовый интервал
00007e e033      	ldi r19, 3			; коррекция
00007f d015      	rcall SendImpuls
                 
000080 e036      	ldi r19, 6
                 SendByteLoop:
000081 e076      	ldi r23, 6			; сначала передаем 6 служебных байт (2 флага и 4 бит контрольной суммы) 
                 						; если bIgnition = 0, то передаются ещё и 3 байта значений напряжений
000082 9161      	ld r22, Z+
                 SendBitLoop:
000083 9567      	ror r22				; передаем МЛАДШИМ битом вперед
000084 d00b      	rcall SendCarry
000085 958a      	dec r24
000086 f041      	breq SendToMainExit
000087 957a      	dec r23
000088 e037      	ldi r19, 7
000089 0000      	nop
00008a 0000      	nop
00008b f7b9      	brne SendBitLoop
00008c e039      	ldi r19, 9
00008d 0000      	nop
00008e cff2      	rjmp SendByteLoop
                 SendToMainExit:
00008f 9508      	ret
                 
                 SendCarry:
000090 f010      	brcs SendCarry1
000091 e124      	ldi r18, (Duration_0)
000092 c002      	rjmp SendImpuls
                 SendCarry1:
000093 e229      	ldi r18, (Duration_1)
000094 0000      	nop
                 SendImpuls:				;
000095 1b23      	sub r18, r19
                 SendImpulsLoop:
000096 952a      	dec r18
000097 f7f1      	brne SendImpulsLoop
000098 9a32      	sbi	PORTB, bLedOut
000099 0000      	nop
00009a 9832      	cbi PORTB, bLedOut
00009b 9508      	ret
                 
                 
                 IgnitionImpuls:			; запустить поджиг через тиристор и ВВ трансформатор
00009c 9831      	cbi PortIgnitionOut, bIgnitionOut	; +Ig в управляющий электрод тиристора
                 IgnitionImpulsLoop:
00009d 950a      	dec r16
00009e f7f1      	brne IgnitionImpulsLoop
00009f 9a31      	sbi PortIgnitionOut, bIgnitionOut	; прекратить +Ig
0000a0 9508      	ret
                 
                 ;**************************************************** Врезка для избежания ошибки относительного перехода (< 127)
                 L_MachInUFire:
0000a1 d074      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
                 
0000a2 2700      	clr r16
0000a3 ad00      	sts	UFireSum, r16			; здесь сумма UFire
0000a4 ad01      	sts (UFireSum + 1), r16		; сначала обнуляем её
0000a5 e015      	ldi r17, InUFire			; с этого входа ADC
                 
0000a6 a128
0000a7 a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000a8 d135      	rcall Get_2_UFireSample_UREF
0000a9 e003      	ldi r16, MachSerialOut	; MachSerialOut - следующий состояние машины
0000aa d059      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
0000ab d13e      	rcall GetFireStatus			; при положительной полуволне считаем статус Fire
0000ac dfa1      	rcall SetSendBuf			; и формируем буфер для передачи
0000ad c003      	rjmp MainLoop
                 
                 L_MachSerialOut:
0000ae d067      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
                 
0000af dfc7      	rcall Send30BitToMain
                 	
                 ;	SetMachStat_r16	MachineState, MachSaveTime	; MachineState = MachSaveTime - следующий шаг цикла
                 ;	rjmp MainLoop
                 
                 L_MachSaveTime:
0000b0 c02a      	rjmp L_MachFrameEnd
                 
                 ;**************************************************** Врезка для избежания ошибки относительного перехода (< 127)
                 
                 
                 ; *********** MAIN LOOP ****************************************************
                 MainLoop:
0000b1 95a8      	wdr
                 	/* парсим MachineState */
0000b2 a100      	lds	r16, MachineState
0000b3 3008      	cpi r16, MachInUPhase0
0000b4 f030      	brlo BelowMachInUPhase0
0000b5 f141      	breq L_MachInUPhase0
                 
0000b6 300b      	cpi r16, MachWaitStart
0000b7 f468      	brsh L_MachWaitStart
                 
0000b8 3009      	cpi r16, MachEndStart
0000b9 f101      	breq L_MachEndStart
0000ba c00d      	rjmp L_MachIgnition		; всё от MachWaitStart до MachEndStart
                 
                 BelowMachInUPhase0:
0000bb 3004      	cpi r16, MachInUFire
0000bc f028      	brlo BelowMachInUFire
0000bd f319      	breq L_MachInUFire
                 
0000be 3006      	cpi r16, MachInUGND0
0000bf f189      	breq L_MachInUGND0
0000c0 f1d8      	brlo L_MachInUGND1
0000c1 c027      	rjmp L_MachInUPhase1
                 
                 BelowMachInUFire:
0000c2 3001      	cpi r16, MachSaveTime	; здесь хитрость - всё, что не MachSaveTime идет на MachSerialOut
0000c3 f361      	breq L_MachSaveTime
0000c4 cfe9      	rjmp L_MachSerialOut
                 
                 L_MachWaitStart:		; **********
0000c5 e009      	ldi r16, MachEndStart	; MachEndStart - следующий состояние машины
0000c6 d03d      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины MachEndStart
0000c7 cfe9      	rjmp MainLoop
                 
                 L_MachIgnition:			; **********
0000c8 d04d      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
                 
0000c9 2700      	clr r16
0000ca ad00      	sts	UFireSum, r16			; здесь сумма UFire
0000cb ad01      	sts (UFireSum + 1), r16		; сначала обнуляем её
0000cc e015      	ldi r17, InUFire			; с этого входа ADC
                 
0000cd a128
0000ce a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000cf d10e      	rcall Get_2_UFireSample_UREF
                 
0000d0 e30c      	ldi r16, 60					; на столько задержка после отсчета UFire
                 IgnLoop:
0000d1 950a      	dec r16
0000d2 0000      	nop
0000d3 f7e9      	brne IgnLoop
                 
0000d4 e10e      	ldi r16, 30					; длительность импульса поджига
0000d5 dfc6      	rcall IgnitionImpuls
                 
0000d6 d113      	rcall GetFireStatus			; при положительной полуволне считаем статус Fire
0000d7 df8f      	rcall SendFire				; формируем буфер для передачи и передаем 6 служебных байт (2 флага и 4 бит контрольной суммы)
                 
0000d8 d035      	rcall WaitPhaseTrue_WaitStopIgnition	; ждать (+) полуволну фазы и ждать окончание поджига
0000d9 cfd7      	rjmp MainLoop
                 
                 L_MachEndStart:			; **********
0000da d03b      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) 
                 							; и установить все времена (неправильно, т.к. нет предыдущего значения Т1 !!!)
                 L_MachFrameEnd:
0000db e008      	ldi r16, MachInUPhase0	; MachInUPhase0 - следующий состояние машины
0000dc d027      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
0000dd cfd3      	rjmp MainLoop
                 
                 L_MachInUPhase0: ; ********** здесь определяем моменты отсчетов переменных напряжений (три отсчета на полупериод) 
                 							; и начинаем накапливать квадраты UPhase
0000de d037      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
                 
0000df e0f0
0000e0 e5ea      	Load_Z_Ptr UPhase2Sum	; здесь сумма квадратов UPhase
0000e1 d0a3      	rcall ClearPZ_24_r16	; сначала обнуляем её
0000e2 e013      	ldi r17, InUPhase		; с этого входа ADC
                 
0000e3 a128
0000e4 a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000e5 d0c4      	rcall Add_3_Sample		; добавляем 3 суммы квадратов отсчетов и 
0000e6 e007      	ldi r16, MachInUPhase1	; MachInUPhase1 - следующий состояние машины
0000e7 d01c      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
0000e8 cfc8      	rjmp MainLoop
                 
                 L_MachInUPhase1: ; ********** продолжаем накапливать квадраты UPhase (ещё три отсчета)
0000e9 d02c      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
0000ea a128
0000eb a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000ec d0bd      	rcall Add_3_Sample		; добавляем 3 суммы квадратов отсчетов и 
0000ed e006      	ldi r16, MachInUGND0	; MachInUGND0 - следующий состояние машины
0000ee d015      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
0000ef d106      	rcall SQRT_Z			; 179 при положительной полуволне считаем средний квадратный корень
0000f0 cfc0      	rjmp MainLoop
                 
                 L_MachInUGND0:  ; ********** начинаем накапливать квадраты отсчетов UGND
0000f1 d024      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
                 
0000f2 e0f0
0000f3 e5ed      	Load_Z_Ptr UGND2Sum ; здесь сумма квадратов UGND
0000f4 d090      	rcall ClearPZ_24_r16	; сначала обнуляем её
0000f5 e012      	ldi r17, InUGND			; с этого входа ADC
                 
0000f6 a128
0000f7 a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000f8 d0b1      	rcall Add_3_Sample		; добавляем 3 суммы квадратов отсчетов и 
0000f9 e005      	ldi r16, MachInUGND1	; MachInUGND1 - следующий состояние машины
0000fa d009      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
0000fb cfb5      	rjmp MainLoop
                 
                 L_MachInUGND1:	 ; ********** продолжаем накапливать квадраты отсчетов UGND
0000fc d019      	rcall WaitPhaseFalse	; ждать (-) полуволну фазы ( T1Value = НОВОЕ состояние Т1) и установить все времена
0000fd a128
0000fe a139      	Load16 r18, r19, TStartPeriod	; начальное значение периода
0000ff d0aa      	rcall Add_3_Sample		; добавляем 3 суммы квадратов отсчетов и 
000100 e004      	ldi r16, MachInUFire	; MachInUFire - следующий состояние машины
000101 d002      	rcall WaitPhaseTrueAndSetMachineState	; ждать (+) полуволну фазы и установить состояние машины
000102 d0f3      	rcall SQRT_Z			; 179 при положительной полуволне считаем средний квадратный корень
000103 cfad      	rjmp MainLoop
                 
                 WaitPhaseTrueAndSetMachineState:
000104 9b20
000105 cffe      	WaitTrue PINB, bPhase	; ждать (+) полуволну фазы
000106 a900      	sts MachineState, r16	; если IgnitionStatus <> 0 то переходим к состоянию машины MachIgnition
000107 a505      	lds r16, IgnitionStatus
000108 3000      	cpi r16, 0
000109 f409      	brne SetIgnitionState
00010a 9508      	ret
                 SetIgnitionState:
00010b e00a      	ldi r16, MachIgnition
00010c a900      	sts MachineState, r16
00010d 9508      	ret
                 
                 WaitPhaseTrue_WaitStopIgnition:	; ждать (+) полуволну фазы и ждать окончание поджига
00010e 9b20
00010f cffe      	WaitTrue PINB, bPhase	; ждать (+) полуволну фазы
000110 a505      	lds r16, IgnitionStatus
000111 3000      	cpi r16, 0
000112 f411      	brne ExitStopIgnition
                 StopIgnition:
000113 e009      	ldi r16, MachEndStart	; MachEndStart - следующий состояние машины (замеры напряжений будем делать через период сети)
000114 a900      	sts MachineState, r16
                 ExitStopIgnition:
000115 9508      	ret
                 
                 .MACRO SetTimeSamples
                 	Load16 r24, r25, T1Value	; Вычисляем длину периода
                 	subi16u r24, r25, CorrectionT	; Вычитаем CorrectionT, так как фиксация начала цикла отстает от перехода фазы через ноль
                 		; и плюс ещё и запуск ADC отстает от срабатывания таймера Т1 - и там и там добавляется время обработки прерывания
                 	Store16 TStartPeriod, r24, r25	; r24:r25 = TStartPeriod -> Старт 0-го периода (счет идет с нулевого!)
                 	
                 	Load16 r24, r25, T1Value	; Вычисляем длину периода
                 	Load16 r22, r23, PreT1Value
                 	Store16 PreT1Value, r24, r25; сохраняем как предыдущее значение T1Value для следующего периода
                 
                 	sub16u r24, r25, r22, r23	; PeriodLength = r24:r25 = r24:r25 - r22:r23
                 TestMaxPeriodLength:
                 	cpi r25, CMinPeriodLength	; минимальный период сетевого напряжения должен быть превышен
                 	brlo BedPeriodLength
                 	cpi r25, CMaxPeriodLength	; а максимальный период сетевого напряжения - нет
                 	brlo StorePeriodLength
                 BedPeriodLength:
                 	clr r16
                 	rjmp StorePeriodStatus
                 StorePeriodLength:
                 	Store16 MachLength, r24, r25; PeriodLength = T1Value - PreT1Value
                 
                 
                 	div16u2 r24, r25			; PeriodLength/2
                 	Store16 LengthDiv2, r24, r25
                 	mov r22, r24
                 	mov r23, r25				; PeriodLength/2
                 	div16u2 r24, r25			; PeriodLength/4
                 	Store16 LengthDiv4, r24, r25
                 
                 	add16u r22, r23, r24, r25
                 	Store16 Length3Div4, r22, r23	; 3/4 периода сети
                 
                 	mov r22, r24
                 	mov r23, r25				; PeriodLength/4
                 	div16u2 r24, r25			; PeriodLength/8
                 	Store16 LengthDiv8, r24, r25	; - четвертушка полупериода
                 
                 	add16u r22, r23, r24, r25
                 	Store16 Length3Div8, r22, r23	; 3/4 полупериода сети
                 
                 	div16u2 r24, r25			; PeriodLength/16
                 	div16u2 r24, r25			; PeriodLength/32
                 	Store16 LengthDiv32, r24, r25	; - 1/16 полупериода сети
                 	Load16 r22, r23, LengthDiv2
                 	add16u r22, r23, r24, r25
                 	Store16 Length17Div32, r22, r23	; 17/32 периода сети - в этот момент будем делать поджиг
                 	ldi r16, 1
                 StorePeriodStatus:
                 .ENDMACRO	; SetTimeSamples
                 
                 
                 WaitPhaseFalse:
000116 d04a      	rcall Receive_r16		; прием - must be MACRO ????
                 ;	rcall SetIgnitionStatusTrue_r16	; DEBUG
                 	
000117 e200
000118 b90b      	WriteByteToReg_r16 GIFR, (1<<PCIF1) ; сбрасываем флаг прерывания
000119 e000
00011a a901      	WriteByteToMem_r16 NewT1Value, 0	; сбрасываем флаг NewT1Value
00011b 9a65      	sbi GIMSK, PCIE1		; разрешаем прерывание PCINT1 -> PCINT1_ISR
                 
                 WaitNewT1Value:				;	WaitFalse PINB, bPhase	; ждать (-) полуволну фазы
00011c a101      	lds r16, NewT1Value
00011d 2300      	tst r16
00011e f3e9      	breq WaitNewT1Value
00011f 9865      	cbi GIMSK, PCIE1		; запрещаем прерывание PCINT1 -> PCINT1_ISR
000120 a182
000121 a193
000122 5180
000123 4090
000124 a988
000125 a999
000126 a182
000127 a193
000128 a164
000129 a175
00012a a984
00012b a995
00012c 1b86
00012d 0b97
00012e 309b
00012f f010
000130 3198
000131 f010
000132 2700
000133 c027
000134 a986
000135 a997
000136 9596
000137 9587
000138 a98a
000139 a99b
00013a 2f68
00013b 2f79
00013c 9596
00013d 9587
00013e a98c
00013f a99d
000140 0f68
000141 1f79
000142 ab64
000143 ab75
000144 2f68
000145 2f79
000146 9596
000147 9587
000148 a98e
000149 a99f
00014a 0f68
00014b 1f79
00014c ab66
00014d ab77
00014e 9596
00014f 9587
000150 9596
000151 9587
000152 ab80
000153 ab91
000154 a16a
000155 a17b
000156 0f68
000157 1f79
000158 ab68
000159 ab79
00015a e001      	SetTimeSamples			; если r16 = 1, то период уложился в допуск и все времена расставлены
00015b 2300      	tst r16
00015c f009      	breq PeriodBed
00015d 9508      	ret
                 PeriodBed:
00015e 9b20
00015f cffe      	WaitTrue PINB, bPhase	; ждать (+) полуволну фазы
000160 cfb5      	rjmp WaitPhaseFalse
                 
                 
                 
                 Receive_r16:	; Ждём флаг Input Capture Flag T1 .. r29 - InputTimeout increment 
                 	; r26 - InputPrevPause предыдущая пауза *2 /256
                 	; r27 - InputDebounce
                 	; r28 - Т1 текущее значение *2 /256
                 	; r29 - InputTimeout increment or local variable
000161 b505      	in r16, TIFR
000162 fd07      	sbrc r16, ICF1 
000163 c008      	rjmp ReceiveTrue
000164 b500      	in r16, TCNT1L
000165 b501      	in r16, TCNT1H
000166 1b0c      	sub r16, r28
000167 3300      	cpi r16, CInputTimeout // здесь сравнение на максимальное значение паузы !!!
000168 f0d8      	brlo Receive_Exit
                 BadReceive:
000169 27bb      	clr r27				; InputDebounce = 0
00016a adb5      	sts IgnitionStatus, r27
00016b 9508      	ret
                 ReceiveTrue:
00016c e800      	ldi r16, (1 << ICF1)
00016d bd05      	out TIFR, r16
00016e b30a      	in r16, ICR1L
00016f b30b      	in r16, ICR1H
000170 2fdc      	mov	r29, r28		; Prev T1
000171 2fc0      	mov	r28, r16
000172 1b0d      	sub r16, r29
000173 2fd0      	mov r29, r16		; ActualPause
000174 3103      	cpi r16, CInputTimeoutMin // здесь сравнение на минимальное значение паузы !!!
000175 f398      	brlo BadReceive
000176 1b0a      	sub r16, r26		; InputPrevPause
000177 2fad      	mov r26, r29
000178 f040      	brcs DeltaMinus
000179 3003      	cpi r16, (CInputMaxJitter + 1)
00017a f440      	brcc ClearInputDebounce
                 IncInputDebounce:
00017b 95b3      	inc	r27
00017c 30b3      	cpi	r27, CInputDebounce
00017d f030      	brcs Receive_Exit
                 SetIgnitionStatusTrue_r16:
00017e e001      	ldi r16, 1
00017f ad05      	sts IgnitionStatus, r16
000180 9508      	ret
                 DeltaMinus:
000181 3f0e      	cpi r16, (0 - CInputMaxJitter)
000182 f7c0      	brcc IncInputDebounce
                 ClearInputDebounce:
000183 27bb      	clr r27
                 Receive_Exit:
000184 9508      	ret
                 
                 ClearPZ_24_r16:		; обнуление 24 бит значения по указателю Z используя r16
000185 2700      	clr r16
000186 9301      	st Z+,r16
000187 9301      	st Z+,r16
000188 9301      	st Z+,r16
000189 50e3      	subi r30, 3		; возвращаем Z на исходное значение
00018a 40f0      	sbci r31, 0
00018b 9508      	ret
                 
                 AddSample:
00018c bb10      	out ADMUX, r17	; канал ADC
00018d bb5f      	out OCR1AH, r21	; устанавливаем момент запуска ADC
00018e bb4e      	out OCR1AL, r20
00018f e008      	ldi r16, (1<<ADLAR) ; выравнивание влево (младшие 2 бита отбрасываем)
000190 bb01      	out ADCSRB, r16
000191 9a94      	sbi ADCSRA, ADIF	; сброс флага прерывания
000192 e100      	ldi r16, (1<<OCIE1A); разрешить прерывание TIM1_COMPA_ISR
000193 bd06      	out TIMSK, r16
000194 9b94
000195 cffe      	WaitTrue ADCSRA, ADIF	; ждать ADC
000196 b16f      	in r22, ADCH	; result
000197 e100      	ldi r16, (1<<ADIF) ; сброс флага и выключение ADC
000198 bb02      	out ADCSRA, r16
000199 2700      	clr r16			; запрет прерывания TIM1_COMPA_ISR
00019a bd06      	out TIMSK, r16 
00019b 2f86      	mov r24, r22
00019c d067      	rcall mpy8u
00019d 8160      	ld r22, Z
00019e 0f68      	add r22, r24
00019f 9361      	st Z+, r22
0001a0 8160      	ld r22, Z
0001a1 1f69      	adc r22, r25
0001a2 9361      	st Z+, r22
0001a3 2700      	clr r16
0001a4 8160      	ld r22, Z
0001a5 1f60      	adc r22, r16
0001a6 9361      	st Z+, r22
0001a7 50e3      	subi r30, 3		; возвращаем Z на исходное значение
0001a8 40f0      	sbci r31, 0
0001a9 9508      	ret
                 
                 Add_3_Sample:
0001aa a14e
0001ab a15f      	Load16 r20, r21, LengthDiv8
0001ac 0f42
0001ad 1f53      	add16u r20, r21, r18, r19	; Ждем первый отсчет в момент r20:r21
0001ae dfdd      	rcall AddSample
                 
0001af a14c
0001b0 a15d      	Load16 r20, r21, LengthDiv4
0001b1 0f42
0001b2 1f53      	add16u r20, r21, r18, r19	; Ждем второй отсчет в момент r20:r21
0001b3 dfd8      	rcall AddSample
                 
0001b4 a346
0001b5 a357      	Load16 r20, r21, Length3Div8
0001b6 0f42
0001b7 1f53      	add16u r20, r21, r18, r19	; Ждем третий отсчет в момент r20:r21
0001b8 dfd3      	rcall AddSample
0001b9 9508      	ret
                 
                 AddUFire:
0001ba bb10      	out ADMUX, r17	; канал ADC
0001bb bb5f      	out OCR1AH, r21	; устанавливаем момент запуска ADC
0001bc bb4e      	out OCR1AL, r20
0001bd 2700      	clr r16			; выравнивание вправо (10 бит)
0001be bb01      	out ADCSRB, r16
0001bf 9a94      	sbi ADCSRA, ADIF	; сброс флага прерывания
0001c0 e100      	ldi r16, (1<<OCIE1A); разрешить прерывание TIM1_COMPA_ISR
0001c1 bd06      	out TIMSK, r16 
0001c2 9b94
0001c3 cffe      	WaitTrue ADCSRA, ADIF	; ждать ADC
0001c4 b18e      	in r24, ADCL	; result UFire
0001c5 b19f      	in r25, ADCH
0001c6 e100      	ldi r16, (1<<ADIF) ; сброс флага и выключение ADC
0001c7 bb02      	out ADCSRA, r16
0001c8 2700      	clr r16			; запрет прерывания TIM1_COMPA_ISR
0001c9 bd06      	out TIMSK, r16 
                 
0001ca a500      	lds r16, UFireSum
0001cb 0f08      	add	r16, r24
0001cc ad00      	sts	UFireSum, r16
0001cd a501      	lds r16, (UFireSum + 1)
0001ce 0f09      	add	r16, r25
0001cf ad01      	sts	(UFireSum + 1), r16
0001d0 9508      	ret
                 
                 GetUREF:				; - must be MACRO ???
0001d1 9a97      	sbi ADCSRA, ADEN	; ADC enable
0001d2 e001      	ldi r16, InUREF
0001d3 bb00      	out ADMUX, r16		; канал ADC
0001d4 9a8b      	sbi ADCSRB, ADLAR	; выравнивание влево (младшие 2 бита отбрасываем)
0001d5 9a94      	sbi ADCSRA, ADIF	; сброс флага прерывания
0001d6 9a96      	sbi ADCSRA, ADSC	; Start ADC Conversion
0001d7 9b94
0001d8 cffe      	WaitTrue ADCSRA, ADIF	; ждать ADC
0001d9 b10f      	in r16, ADCH		; result UREF
0001da ad03      	sts UREFVal, r16
0001db e100      	ldi r16, (1<<ADIF) ; сброс флага и выключение ADC
0001dc bb02      	out ADCSRA, r16
0001dd 9508      	ret
                 
                 Get_2_UFireSample_UREF:			; - must be MACRO ???
0001de a340
0001df a351      	Load16 r20, r21, LengthDiv32
0001e0 0f42
0001e1 1f53      	add16u r20, r21, r18, r19	; Ждем первый отсчет UFire в момент r20:r21
0001e2 dfd7      	rcall AddUFire
0001e3 dfed      	rcall GetUREF
0001e4 a348
0001e5 a359      	Load16 r20, r21, Length17Div32
0001e6 0f42
0001e7 1f53      	add16u r20, r21, r18, r19	; Ждем второй отсчет UFire в момент r20:r21
0001e8 dfd1      	rcall AddUFire
0001e9 9508      	ret
                 
                 GetFireStatus:  ; сдвиг UFireSum на три разряда вправо (сумму 2-х 10-бит значений приводим к 8 битам) - must be MACRO ???
                 				; и сравнение с UFirePorog. Результат - младший бит в FireStatus
0001ea e003      	ldi r16, 3
0001eb a571      	lds r23, (UFireSum + 1)
0001ec a560      	lds r22, UFireSum
                 GetFireStatus_L0:
0001ed 9576      	lsr r23
0001ee 9567      	ror	r22
0001ef 950a      	dec	r16
0001f0 f7e1      	brne GetFireStatus_L0
                 	; r22 - UFire
0001f1 5860      	subi r22, UFirePorog
0001f2 2766      	clr r22
0001f3 1f66      	rol r22
0001f4 ad62      	sts FireStatus, r22
0001f5 9508      	ret
                 
                 SQRT_Z: ; квадратный корень из деленного на 8 того, на что указывает Z 
                 		; на самом деле суммировались 6 квадратов отсчетов, плюс 2 нулевых. Регистры используем ЛЮБЫЕ
0001f6 e003      	ldi r16, 3
0001f7 9161      	ld r22, Z+
0001f8 9171      	ld r23, Z+
0001f9 9181      	ld r24, Z+
                 SQRT_Z_L0:
0001fa 9586      	lsr r24
0001fb 9577      	ror	r23
0001fc 9567      	ror	r22
0001fd 950a      	dec	r16
0001fe f7d9      	brne SQRT_Z_L0	; поделили на 8. Результат не более 16 бит.
0001ff d00e      	rcall SQRT		; До 195 тактов; r22:r23. Value - входное значение; выходное r20:r21 - корень
000200 50e3      	subi r30, 3		; возвращаем Z на исходное значение
000201 40f0      	sbci r31, 0
000202 8340      	st Z, r20
000203 9508      	ret
                 
                 	
                 ;***************************************************************************
                 ;*
                 ;* "mpy8u" - 8x8 Bit Unsigned Multiplication
                 ;*
                 ;* This subroutine multiplies the two register variables mp8uL and mc8u.
                 ;* The result is placed in registers m8uH, mp8uL
                 ;*  
                 ;* Number of words	:9 + return
                 ;* Number of cycles	:58 + return
                 ;* Low registers used	:None
                 ;* High registers used  :4 (mc8u,mp8uL,m8uH,mcnt8u)	
                 ;*
                 ;* Note: Result Low byte and the multiplier share the same register.
                 ;* This causes the multiplier to be overwritten by the result.
                 ;*
                 ;***************************************************************************
                 
                 ;***** Subroutine Register Variables
                 
                 .def	mc8u	=r22		;multiplicand
                 .def	mcnt8u	=r23		;loop counter
                 .def	mp8uL	=r24		;multiplier & result Low byte
                 .def	m8uH	=r25		;result High byte
                 
                 ;***** Code
                 mpy8u:	
000204 2799      	clr	m8uH		;clear result High byte
000205 e078      	ldi	mcnt8u,8	;init loop counter
000206 9586      	lsr	mp8uL		;rotate right result L byte and multiplier
                 m8u_1:
000207 f408      	brcc m8u_2		;carry set 
000208 0f96      	add m8uH,mc8u	;add multiplicand to result High byte
                 m8u_2:	
000209 9597      	ror	m8uH		;rotate right result High byte
00020a 9587      	ror	mp8uL		;rotate right result L byte and multiplier
00020b 957a      	dec	mcnt8u		;decrement loop counter
00020c f7d1      	brne m8u_1		;if not done, loop more
00020d 9508      	ret
                 
                 ; ****** http://www.microchip.com/forums/m577584.aspx ******
                 SQRT: ; Вычисление квадратного корня беззнакового 16 бит числа. До 179 тактов
                 	; r22:r23. Value - входное значение, выходное r20:r21 - корень
                 	; r20:r21 - Root
                 	; r24:r25 - Bit
                 	; r18:r19 - Trial
00020e 2744      	clr r20			; unsigned Root = 0
00020f 2755      	clr r21
000210 2788      	clr r24			; unsigned Bit    for ( Bit = 0x4000; Bit > 0; Bit >>= 2 )
000211 e490      	ldi r25, 0x40
                 SQRT_L1:
000212 2f24      	mov r18, r20	; unsigned Trial = Root + Bit;
000213 2f35      	mov r19, r21
000214 0f28      	add r18, r24
000215 1f39      	adc r19, r25
000216 9556      	lsr r21			; Root >>= 1;
000217 9547      	ror r20
000218 1762      	cp r22, r18		; if ( Trial <= Value )
000219 0773      	cpc r23, r19
00021a f020      	brcs SQRT_L2
00021b 0f48      	add r20, r24	; Root += Bit;
00021c 1f59      	adc r21, r25
00021d 1b62      	sub r22, r18	; Value -= Trial;
00021e 0b73      	sbc r23, r19
                 SQRT_L2:
00021f 9596      	lsr r25			; Bit >>= 2
000220 9587      	ror r24
000221 9596      	lsr r25
000222 9587      	ror r24
000223 2388      	tst r24			; Bit > 0 ?
000224 f769      	brne SQRT_L1
000225 2399      	tst r25
000226 f759      	brne SQRT_L1
000227 9508      	ret
                 
                 ; Fill memory by NOP (code = 0x0000) in ST Visual Programmer
                 
                 	.ORG	FLASHEND
                 LastProgMemory:
0003ff cc34      	rjmp	HOT_reset
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny20" register use summary:
r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 172 r17:   8 r18:  32 r19:  31 r20:  17 r21:  16 r22:  35 r23:  21 
r24:  38 r25:  35 r26:   3 r27:   8 r28:   3 r29:   4 r30:   6 r31:   6 
x  :   0 y  :   0 z  :  14 
Registers used: 17 out of 35 (48.6%)

"ATtiny20" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :  12 add   :  19 and   :   0 andi  :   3 
asr   :   0 bclr  :   0 bld   :   7 brbc  :   0 brbs  :   0 brcc  :   3 
brcs  :   4 breq  :   8 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   7 brlt  :   0 brmi  :   0 brne  :  11 brpl  :   0 
brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   3 cbi   :   3 cbr   :   0 clc   :   0 clh   :   0 cli   :   0 
cln   :   0 clr   :  20 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   0 cp    :   1 cpc   :   1 cpi   :  15 cpse  :   0 dec   :   8 
eor   :   1 icall :   0 ijmp  :   0 in    :  12 inc   :   1 ld    :   7 
ldd   :   0 ldi   :  69 lds   :  92 lsl   :   2 lsr   :  11 mov   :  12 
neg   :   0 nop   :   6 or    :   1 ori   :   0 out   :  36 pop   :   0 
push  :   0 rcall :  44 ret   :  21 reti  :   2 rjmp  :  44 rol   :   1 
ror   :  14 sbc   :   2 sbci  :   4 sbi   :  11 sbic  :   0 sbis  :   6 
sbr   :   0 sbrc  :   1 sbrs  :   1 sec   :   0 seh   :   0 sei   :   1 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   0 st    :   7 std   :   0 sts   :  94 sub   :   6 subi  :   5 
swap  :   1 tst   :   4 wdr   :   1 
Instructions used: 49 out of 99 (49.5%)

"ATtiny20" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000800   1106      0   1106    2048  54.0%
[.dseg] 0x000040 0x00006a      0     42     42     128  32.8%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 0 warnings
